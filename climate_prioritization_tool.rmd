---
title: "Africa Atlas - Hazards Prototype"
author: "Peter Steward, Todd Rosenstock, Ani Ghosh, Julian Ramirez, Shalika Vyas"
date: "12/09/2023"
output: html_document
runtime: shiny
---
  
<style type="text/css">
.main-container {
max-width: 2400px;
margin-left: auto;
margin-right: auto;
}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
options(scipen = 999)
```

```{r Load packages,echo=F,message=F,warning=F}

if(!require("pacman", character.only = TRUE)){install.packages("pacman",dependencies = T)}

required.packages <- c("countrycode",
                       "data.table",
                       "devtools",
                       "dplyr",
                       "DT",
                       "forcats",
                       "ggplot2",
                       "MetBrewer",
                       "mgsub",
                       "miceadds",
                       "rgdal",
                       "stringr",
                       "terra",
                       "viridis",
                       "wbstats",
                       "wesanderson"
                       )

pacman::p_load(char=required.packages,install = T,character.only = T)
```

```{r Load functions,echo=F,message=F,warning=F}
source("R/haz_functions.R")
```

## EiA Climate Prioritization Tool {.tabset .tabset-fade .tabset-pills}

```{r Find country data in zip files,echo=F}
country_zips<-data.table(filepath=list.files("./Data/country_data_zips",".zip",full.names = T))
country_zips[,iso3c:=unlist(tstrsplit(tail(tstrsplit(filepath,"/"),1),"-",keep=1)),by=filepath
             ][,timeframe:=gsub(".zip","",unlist(tstrsplit(tail(tstrsplit(filepath,"/"),1),"-",keep=2)),"-"),by=filepath
               ][timeframe=="seasonal",timeframe:="seasonal_jagermeyer_cc"]
country_zips[,folder:=gsub(".zip","",unlist(tail(tstrsplit(filepath,"/"),1)))]
country_zips[,Country:=countrycode::countrycode(iso3c, origin = 'iso3c', destination = 'country.name')]

```

```{r Hazards - load meta data and class breaks,echo=F}
hazards<-sort(c("NDD","NTx40","NTx35","HSH_max","HSH_mean","THI_max","THI_mean","NDWS","TAI","NDWL0","PTOT","TAVG"))
haz_meta<-data.table::fread("./Data/metadata/haz_metadata.csv")
haz_class<-fread("./Data/metadata/haz_classes.csv")
haz_class[is.na(lower_lim),lower_lim:=-Inf]
haz_classes<-unique(haz_class$description)

Scenarios<-c("ssp245","ssp585")
Times<-c("2021_2040","2041_2060")
Scenarios<-rbind(data.table(Scenario="historic",Time="historic"),data.table(expand.grid(Scenario=Scenarios,Time=Times)))
Scenarios[,combined:=paste0(Scenario,"-",Time)]

scenarios_x_hazards<-data.table(Scenarios,Hazard=rep(hazards,each=nrow(Scenarios)))[,Scenario:=as.character(Scenario)][,Time:=as.character(Time)]
                          
```

:::: {style="display: flex;"}
:::{}
```{r Choose country,echo=F}
selectInput(inputId="country_choice", 
              label="Choose country",
              choices = unique(country_zips$Country),
              selected = "Tanzania",
              multiple = F, 
              width="240px")
```
:::
:::{}
```{r Choose timeframe,echo=F}
renderUI({
selectInput(inputId="timeframe_choice", 
              label="Climate variables calculated seasonally or annually?",
              choices = unique(country_zips[Country==input$country_choice,timeframe]),
              selected = "annual",
              multiple = F, 
              width="360px")
})
```
:::
:::{}
```{r Hazard Thresholds PropThreshold,echo=F}
numericInput(inputId="PropThreshold",
           label="Recurrence threshold", 
           value=0.5,
           min=0,
           max=0.1,
           step=1,
           width="200px")
```
:::
:::{}
```{r Future -  Choose scenario, echo=F}
  selectInput(inputId="Future", 
              label="Choose future scenario",
              choices =  Scenarios$combined[-1],
              selected =  "ssp585-2041_2060",
              multiple = F, 
              width="180px")

```
:::
::::

Hazards can be calculated annually or seasonally: `annual` = for a year beginning with the planting date of the main season (using Jagermeyer crop calendar), `seasonal_sos_primary` = main growing season calculated using onset of rainfall, `seasonal_sos_secondary` = subordinate growing season calculated using onset of rainfall, `jagermeyer` = main growing season calculated using the [GGCMI Phase3 crop calendar]( https://zenodo.org/record/5062513).  

The `Reccurence threshold` is used when classifying hazards based on the proportions of seasons a hazard is present in a time series of data. If set to 0.5 then a hazard is considered present if it is present in more than 50% of seasons. 
*Note if season is selected then all hazards are calculated for the maize growing season.*  
*Historical = 1995 to 2013. Note, future scenarios are a multi-model ensemble mean of five models: ACCESS-ESM1-5, MPI-ESM1-2-HR, EC-Earth3, INM-CM5-0, MRI-ESM2-0*

```{r Unzip country zip,echo=F}
country_dir<-reactive({
  paste0("Data/country_data/", country_zips[Country==input$country_choice & timeframe==input$timeframe_choice,folder])
  })

ocha_dir<-reactive({
  paste0("Data/ocha_boundaries/", country_zips[Country==input$country_choice & timeframe==input$timeframe_choice,iso3c])
  })

reactive({
  if(!dir.exists(country_dir())){
    dir.create(country_dir(),recursive = T)
    unzip(zipfile=country_zips[Country==input$country_choice & timeframe==input$timeframe_choice,filepath],exdir=country_dir(),junkpaths=T)
  }
})

SaveDir<-reactive({
  paste0(country_dir(),"/Analysis")
  })

reactive({
  if(!dir.exists(SaveDir())){
    dir.create(SaveDir())
  }
})

```

**Plotting Parameters** - here you can adjust some plot features such as colour palette, text size, and plot size.

:::: {style="display: flex;"}
:::{}
```{r Plot - Palette,echo=F,eval=T}

Viridis<-data.table(Source="viridis",Palette=c("magma","inferno","plasma","viridis","cividis","rocket","mako","turbo"))
Met<-data.table(Source="MetBrewer",Palette=names(MetBrewer::MetPalettes))
Wes<-data.table(Source="wesanderson",Palette=names(wesanderson::wes_palettes))

Palettes<-rbind(Viridis,Met,Wes)

  selectInput(inputId="Palette", 
              label="Palette",
              choices = Palettes[,sort(Palette)],
              selected="turbo", 
              multiple = F, 
              width="150px")
  
```
:::
:::{}
```{r Plot - Text Size, echo=F}
numericInput(inputId="TextSize",
             label="Text Size",
             value=1.5,
             min=1,
             max=5,
             step=0.1,
             width="80px")
```
:::
:::{}
```{r Plot - LegPos,echo=F}
  selectInput(inputId="LegPos", 
              label="Legend position",
              choices = c("bottomright", "bottom", "bottomleft", "left", "topleft", "top", "topright", "right","center"),
              selected="bottomleft", 
              multiple = F,
              width="160px")
```
:::
:::{}
```{r Plot - Legend Columns, echo=F}
numericInput(inputId="LegCols",
             label="No. Legend Columns",
             value=1,
             min=1,
             max=5,
             step=1,
             width="140px")
```
:::
:::{}
```{r Plot - Border width , echo=F}
numericInput(inputId="borderwidth",
             label="Border width",
             value=1,
             min=0.1,
             max=5,
             step=0.25,
             width="120px")
```
:::
:::{}
```{r Plot - Base width,echo=F}
  numericInput(inputId="PlotBaseWidth", 
              label="Plot width (px)",
              value = 1800,
              min=100, 
              max=5000,
              step = 100,
              width="150px")
```
:::
:::{}
```{r  Plot - Adjust height, echo=F}
numericInput(inputId="Plot.Height",
             label="Adjust height",
             value=0.3,
             min=0.1,
             max=3,
             step=0.1, 
             width="120px")
```
:::
:::{}
```{r Plot - Adjust width , echo=F}
numericInput(inputId="Plot.Width",
             label="Adjust width",
             value=0.6,
             min=0.1,
             max=3,
             step=0.1,
             width="120px")
```
:::
::::

```{r Plot - Create bar height and width functions, echo=F}
  Plot.Height <- function(){input$PlotBaseWidth*input$Plot.Height}
  Plot.Width <- function(){input$PlotBaseWidth*input$Plot.Width}
```

```{r Plot - create ggplot theme,echo=F}
 ggplot_theme<-reactive({
   X<-theme_minimal()
   X<-X+theme(axis.text = element_text(size = 10*input$TextSize),
              axis.title = element_text(size = 11*input$TextSize),
              plot.title = element_text(size = 12*input$TextSize),
              strip.text = element_text(size = 11*input$TextSize),
              legend.text = element_text(size = 10*input$TextSize),
              legend.title = element_text(size = 11*input$TextSize)) 
   X
 })
```
### User Notes
 <font size="5">
 * This is an analytically heavy script and a prototype.  
 * Be patient!  
 * The first time you access the Results section for a country it will take many minutes to process the data (the same goes for changing calculation of climate variables from seasonal to annual). Check the Render tab in RStudio to see progress on tasks running.  
 * Please go through the tabs in order as there are dependencies between tabs. Let each tab complete before moving to the next.  
 When changing country, seasonal or annual timeframe or admin unit from admin1 to admin2, return to the Admin and Exposure Datasets tabs and wait for it to update before moving through the tabs.  
 * If a tab is not updating when you have changed a selection, be patient, do not change any more selections (this will just make things worse.  
 * If it gets stuck restart the rmarkdown.
</font> 
  
<font size="5">
**Please see the `Create Hazards` tab, the thresholds selected are created from literature review and expert opinion, but it is your responsibility to review these and modify as required.**
</font> 

<font size="4">
You will need to download country dataset zip files into the Data/country_data_zips folder of this R project.  
The country zips are currently housed in CGlabs the `common_data/atlas_hazards/cimp6/indices/hazard_by_gadm0` folder in the `by_year` and `by_season` subfolders :
https://eia.scio.services:18002/hub/user-redirect/lab/tree/common_data/atlas_hazards/cmip6/indices/hazard_by_gadm0  

`by_year` = hazard are calculated annually (example `KEN-annual.zip`)  
`by_season` = hazard are calculated for the maize growing season according to the Jagermier crop calendar (example `KEN-seasonal.zip`)
</font> 

<font size="4">
If you want to replace the default GADM 4.1 administrative boundaries with OCHA datasets, download and unzip the OCHA
files to the `./Data/ocha_boundaries` directory into a folder with the capitalized ISO3 name of the country. The example Egpyt is `./Data/ocha_boundaries/EGY`. You will need to unzip layers for admin0, admin1, and admin2. The unzipped files should not be in sub-folders. If you have previously run analysis using GADM 4.1 you will also need to delete the corresponding analysis folders for the country the data folder `./country_data`, e.g. `./Data/ocha_boundaries/EGY-annual/Analysis`, `./Data/ocha_boundaries/EGY-jagermeyr/Analysis`, etc.
</font> 

### Datasets {.tabset .tabset-fade .tabset-pills}

#### Admin
```{r Dataset - load regions,echo=F}
# Make a list of different administrative unit vectors
Geographies<-reactive({
if(dir.exists(ocha_dir())){
  unlink(list.files(ocha_dir(),".xml",full.names = T))

  # OCHA format
  Geographies<-list(
    admin2=terra::aggregate(terra::vect(grep("_adm2_",list.files(ocha_dir(),".shp",full.names = T),value = T)),by="ADM2_EN"),
    admin1=terra::aggregate(terra::vect(grep("_adm1_",list.files(ocha_dir(),".shp",full.names = T),value = T)),by="ADM1_EN"),
    admin0=terra::vect(grep("_adm0_",list.files(ocha_dir(),".shp",full.names = T),value = T))
  )
  
  # Create standard name field for each admin vector
  Geographies$admin2$NAME_2<-Geographies$admin2$ADM2_EN
  Geographies$admin2$NAME_1<-Geographies$admin2$ADM1_EN
  Geographies$admin1$NAME_1<-Geographies$admin1$ADM1_EN
  Geographies$admin0$COUNTRY<-Geographies$admin0$ADM0_EN
  
}else{ 
  # GADM format
  Geographies<-list(
    admin2=terra::aggregate(terra::vect(grep("_2.shp",list.files(country_dir(),full.names = T),value = T)),by="NAME_2"),
    admin1=terra::aggregate(terra::vect(grep("_1.shp",list.files(country_dir(),full.names = T),value = T)),by="NAME_1"),
    admin0=terra::vect(grep("_0.shp",list.files(country_dir(),full.names = T),value = T))
  )

}
  
# Create standard name field for each admin vector
Geographies$admin2$admin_name<-Geographies$admin2$NAME_2
Geographies$admin1$admin_name<-Geographies$admin1$NAME_1
Geographies$admin0$admin_name<-Geographies$admin0$COUNTRY
  
Geographies
})

# Which units are lakes?
#Geographies$NAME_2[grep("Lake ",Geographies$NAME_2)]
```

:::{}
:::{.column width="33%"}

```{r Plot - admin2,echo=F}
renderPlot({terra::plot(Geographies()[[1]],
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            main="Admin2",
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize))})
```
:::
:::{.column width="33%"}

```{r Plot - admin1,echo=F}
renderPlot({terra::plot(Geographies()[[2]],
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            main="Admin1",
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize))})
```
:::
:::{.column width="33%"}

```{r Plot - admin0,echo=F}
renderPlot({terra::plot(Geographies()[[3]],
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            main="Admin0",
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize))})
```
:::
:::

#### Exposure
```{r Dataset - load exposure,echo=F}
Exposure<-reactive({
  terra::rast(paste0(country_dir(),"/Exposure.tif"))
  })
```

Cropland extent data (source: https://glad.umd.edu/dataset/croplands)
```{r Dataset - Load global crop land extent,echo=F}
Cropland<-reactive({
  X<-Exposure()$`cropland-area-ha`
  names(X)<-"Cropland_Area"
  X
})

renderPlot({terra::plot(Cropland(),
            cex.main = input$TextSize*1.2,
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            pax=list(cex.axis = input$TextSize))},height=Plot.Height, width=Plot.Width)
```

Rural population data:
```{r Dataset - Load population,echo=F}
TotalPop<-reactive({
    X<-Exposure()$`rural_pop-total-k`
    names(X)<-"TotalPop"
    X
})

renderPlot({terra::plot(TotalPop(),
            cex.main = input$TextSize*1.2,
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            pax=list(cex.axis = input$TextSize))},height=Plot.Height, width=Plot.Width)
```

Plot MapSPAM data:
```{r Dataset - mapSPAM,echo=F}

ms_codes<-data.table::fread("./Data/metadata/SpamCodes.csv")[,Code:=toupper(Code)]

SPAM<-reactive({
  Exposure()[[grep("harvested_area|vop_total|production-mt",names(Exposure()),value = T)]]
  })

renderPlot({terra::plot(SPAM(),
                        cex.main = input$TextSize*1.2,
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        pax=list(cex.axis = input$TextSize))},height=Plot.Height, width=Plot.Width)

```

[Livestock population data](https://dataverse.harvard.edu/dataverse/glw_3) by [Gilbert et al., 2018](https://www.nature.com/articles/sdata2018227)

We are using interpolated rasters indicated by `_Da` in the filename.

We convert number of livestock into total livestock units (TLU) as per [Rothman-Ostrow et al. 2020](https://www.frontiersin.org/articles/10.3389/fvets.2020.556788/full): `TLU<-Cattle*0.7 + Buffalo*0.7 + Sheep*0.1 + Goat*0.1 + 0.01*Chicken + 0.2*Pig + 0.8*Horse`

```{r Dataset - GLW,echo=F}
GLW_meta<-fread("./Data/metadata/livestock_GLW3_metadata.csv")

GLW<-reactive({
  Exposure()[[grep("goats|pigs|cattle|buffalo|sheep|livestock|chickens|horses",names(Exposure()),value = T)]]
})

renderPlot({terra::plot(GLW(),
                        cex.main = input$TextSize*1.2,
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        pax=list(cex.axis = input$TextSize))},height=Plot.Height, width=Plot.Width)
```

[GLPC Livestock Production Systems (LPS) map](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/WPDSZE) by [Robinson et al. 2014](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0096084):
```{r Dataset - GLPS,echo=T}
GLPS_Legend<-data.table::fread("Data/metadata/LPS_legend_RGB.csv")

GLPS<-reactive({
  GLPS<-terra::rast("./Data/GLPS/glps_gleam_61113_10km.tif")
  levels(GLPS)<-data.frame(value=1:15,LPS=GLPS_Legend[1:15,System_Full])
  GLPS<-terra::mask(terra::crop(terra::resample(GLPS,Exposure(),method="near"),Geographies()$admin0),Geographies()$admin0)
  GLPS
})

renderPlot({terra::plot(GLPS(),
            cex.main = input$TextSize*1.2,
            main="LPS",
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            pax=list(cex.axis = input$TextSize))},height=Plot.Height, width=Plot.Width)

```

```{r Dataset - Join SPAM and GLW,echo=F}
SPAM_GLW<-reactive({
  Exposure()[[!grepl("rural_pop|cropland-area",names(Exposure()))]]
})
```

```{r Analysis - Process MapSPAM,eval=T,echo=F}

exposure_by_admin<-reactive({
  
  if(!dir.exists(paste0(country_dir(),"/exposure_by_admin"))){
    dir.create(paste0(country_dir(),"/exposure_by_admin"))
  }
  
  ms_file<-paste0(country_dir(),"/exposure_by_admin/exposure_by_admin.csv")

  if(!file.exists(ms_file)){
  
  GeogRast<-terra::rasterize(Geographies()$admin2,SPAM_GLW(),field="NAME_2")
  
  exposure_by_admin<-data.table(terra::zonal(SPAM_GLW(),GeogRast,"sum",na.rm=T))
  exposure_by_admin<-data.table::melt(exposure_by_admin,id.vars = "NAME_2",variable.name = "layer_name",value.name = "value")
  exposure_by_admin<-merge(exposure_by_admin,data.table(values(Geographies()[[1]]))[,list(NAME_1,NAME_2)],by="NAME_2",all.x=T)
  exposure_by_admin[,variable:=unlist(tstrsplit(layer_name,"-",keep=2))
                    ][,unit:=unlist(tstrsplit(layer_name,"-",keep=3))
                      ][,product:=unlist(tstrsplit(layer_name,"-",keep=1))
                        ][,value:=round(value,3)]
  
  setnames(exposure_by_admin,c("NAME_2","NAME_1"),c("admin2","admin1"))
  
  data.table::fwrite(exposure_by_admin,file=ms_file)

  }else{
    exposure_by_admin<-data.table::fread(ms_file)
  }
  
  exposure_by_admin
})

```

```{r Plot - Exposure by geography,echo=F}
renderDT({
  datatable(exposure_by_admin(),
            caption="Exposure by geography",
            extensions = 'Buttons',
            filter = "top",
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  
})
```

```{r Dataset- show Exposure names,echo=F}
exposure_layers<-reactive({
  X<-data.table(layer_name=names(SPAM_GLW()))
  X[,product:=unlist(tstrsplit(layer_name,"-",keep=1))
                ][,variable:=unlist(tstrsplit(layer_name,"-",keep=2))
                  ][,unit:=unlist(tstrsplit(layer_name,"-",keep=3))
                    ][,category:="crop"
                      ][product %in% c("goats","sheep","pigs","cattle","chickens","horses","livestock","buffalo"),category:="livestock"]
  X
})

if(F){
  renderDT({
    datatable(exposure_layers(),
              caption="Trends table",
              extensions = 'Buttons',
              filter = "top",
              options = list(dom = 'Blfrtip',
                             buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                             lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
    
  })
}
```

#### Crop Calendar
```{r Dataset - Crop Calendar Plot,echo=F}
crop_cal<-reactive({
  crop_cal_files<-paste0(country_dir(),c("/cropcal_rast.tif","/crop_cal.tif"))
  crop_cal_files<-crop_cal_files[file.exists(crop_cal_files)]
  if(length(crop_cal_files)==1){
    crop_cal<-terra::rast(crop_cal_files)
    crop_cal<-terra::mask(terra::crop(crop_cal,Geographies()$admin0),Geographies()$admin0)
    crop_cal
  }else{
    crop_cal<-NULL
  }
  
  crop_cal
})

renderPlot({terra::plot(crop_cal(),
            cex.main = input$TextSize*1.2,
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            pax=list(cex.axis = input$TextSize))},height=Plot.Height, width=Plot.Width)

```

```{r Dataset - Crop Calendar Histogram,echo=F,message=FALSE,error=FALSE}
cc_hist<-reactive({

 data<-rbind(data.table(terra::values(crop_cal()$S1),season="S1"),
             data.table(month=terra::values(crop_cal()$S2),season="S2"),use.names=F)
 
 colnames(data)<-c("start_month","season")
 
 data<-data[!is.na(start_month),list(N=.N),by=list(start_month,season)]
 g<-ggplot(data, aes(x = start_month, y=N,fill = season)) +  
   geom_bar(stat = "identity") +
   ggplot_theme()
 g
})

renderPlot({plot(cc_hist(),
            cex.main = input$TextSize*1.2,
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            pax=list(cex.axis = input$TextSize))},height=Plot.Height, width=Plot.Width)
```

### Create Hazards (HIDDEN)

**Define hazard thresholds**  
See https://github.com/AdaptationAtlas/hazards for how hazards layers were created.

**HSH_max** = `r haz_meta[grepl("HSH_max",file.filename),dataset.desc]`   
**HSH_mean** = `r haz_meta[grepl("HSH_mean",file.filename),dataset.desc]`   
**NDD** = `r haz_meta[grepl("NDD",file.filename),dataset.desc]`  
**NDWL0** = `r haz_meta[grepl("NDWL0",file.filename),dataset.desc]`  
**NDWS** = `r haz_meta[grepl("NDWS",file.filename),dataset.desc]`  
**NTx35** = `r haz_meta[grepl("NTx35",file.filename),dataset.desc]`  
**NTx40** = `r haz_meta[grepl("NTx40",file.filename),dataset.desc]`  
**PTOT** = `r haz_meta[grepl("PTOT",file.filename),dataset.desc]`  
**TAI** = `r haz_meta[grepl("TAI",file.filename),dataset.desc]`  
**TAVG** = `r haz_meta[grepl("TAVG",file.filename),dataset.desc]`  
**THI_max** = `r haz_meta[grepl("THI_max",file.filename),dataset.desc]`  
**THI_mean** = `r haz_meta[grepl("THI_mean",file.filename),dataset.desc]`

Use the table below set hazard thresholds and the direction of classification (`<` lower or '>' higher than the threshold), and the bottom row to rename the hazard. Note renaming hazards requires recalculation of combined hazards and therefore takes time. When renaming variables **DO NOT** use underscores `_` or the reserved words `mean`,`meanclass`,`prop`,`propclass`,`exceedmean`, `exceedmax`.  

:::: {style="display: flex;"}
::: {}
```{r Hazard names 1,echo=F}
textInput(inputId="H1_Name", 
             label=haz_meta[grepl(hazards[1],file.filename),dataset.title_short],
              value = hazards[1],
              width="140px")
```
:::
:::{}
```{r Hazard names 2,echo=F}
textInput(inputId="H2_Name", 
             label=haz_meta[grepl(hazards[2],file.filename),dataset.title_short],
              value = hazards[2],
              width="140px")
```
:::
:::{}
```{r Hazard names 3,echo=F}
textInput(inputId="H3_Name", 
             label=haz_meta[grepl(hazards[3],file.filename),dataset.title_short],
              value = hazards[3],
              width="140px")
```
:::
:::{}
```{r Hazard names 4,echo=F}
textInput(inputId="H4_Name", 
             label=haz_meta[grepl(hazards[4],file.filename),dataset.title_short],
              value = hazards[4],
              width="140px")
```
:::
:::{}
```{r Hazard names 5,echo=F}
textInput(inputId="H5_Name", 
             label=haz_meta[grepl(hazards[5],file.filename),dataset.title_short],
              value = hazards[5],
              width="140px")
```
:::
:::{}
```{r Hazard names 6,echo=F} 
textInput(inputId="H6_Name", 
             label=haz_meta[grepl(hazards[6],file.filename),dataset.title_short],
              value = hazards[6],
              width="140px")
```
:::
:::{}
```{r Hazard names 7,echo=F} 
textInput(inputId="H7_Name", 
             label=haz_meta[grepl(hazards[7],file.filename),dataset.title_short],
              value = hazards[7],
              width="140px")
```
:::
:::{}
```{r Hazard names 8,echo=F}  
textInput(inputId="H8_Name", 
             label=haz_meta[grepl(hazards[8],file.filename),dataset.title_short],
              value = hazards[8],
              width="140px")
```
:::
:::{}
```{r Hazard names 9,echo=F} 
textInput(inputId="H9_Name", 
             label=haz_meta[grepl(hazards[9],file.filename),dataset.title_short],
              value = hazards[9],
              width="140px")
```
:::
:::{}
```{r Hazard names 10,echo=F}  
textInput(inputId="H10_Name", 
             label=haz_meta[grepl(hazards[10],file.filename),dataset.title_short],
              value = hazards[10],
              width="140px")
```
:::
:::{}
```{r Hazard names 11,echo=F}  
textInput(inputId="H11_Name", 
             label=haz_meta[grepl(hazards[11],file.filename),dataset.title_short],
              value = hazards[11],
              width="140px")
```
:::
:::{}
```{r Hazard names 12,echo=F}  
textInput(inputId="H12_Name", 
             label=haz_meta[grepl(hazards[12],file.filename),dataset.title_short],
              value = hazards[12],
              width="140px")
```
:::
::::

Create table of thresholds and filenames:
```{r Analysis - Create thresholds table and filenames, echo=F}
Thresholds<-reactive({
  haz_names<-data.table(Variable=hazards,
             Renamed=c(input$H1_Name,input$H2_Name,input$H3_Name,input$H4_Name,input$H5_Name,input$H6_Name,input$H7_Name,input$H8_Name,input$H9_Name,input$H10_Name,input$H11_Name,input$H12_Name))
  
  Thresholds<-haz_class[description!="No significant stress",list(index_name,description,lower_lim,upper_lim,direction)]
  setnames(Thresholds,c("index_name","description","direction"),c("Variable","Severity_class","Direction"))
  Thresholds<-merge(Thresholds,haz_names,by="Variable",all.x=T)
  
  Thresholds[Direction=="<",Threshold:=upper_lim
           ][Direction==">",Threshold:=lower_lim
             ][,Code:=paste0(Direction,Threshold)
               ][,Code:=gsub("<","L",Code)
                 ][,Code:=gsub(">","G",Code)
                   ][,Threshold:=NULL
                     ][,Code:=paste0(Variable,Code)]
  Thresholds
  })


renderPrint({Thresholds()})

FileName<-reactive({
  Thresholds[,paste0(unique(Code),collapse="")]
})

renderPrint({FileName()})

```

#### Detect and classify hazards

```{r Analysis - Classify hazards}
Hazards<-reactive({
  HazardWrapper(Thresholds=Thresholds(),
                SaveDir=SaveDir(),
                PropThreshold=input$PropThreshold,
                PropTDir=">",
                hazard_dir= country_dir(),
                Scenarios=Scenarios)
})

renderPrint({names(Hazards())})
renderPrint({names(Hazards()[[1]])})
```

### Results {.tabset .tabset-fade .tabset-pills}
Here you can select which products, hazards and geographies to display. Selecting the hazards to display here does not affect the calculation or display of combined hazards.

:::: {style="display: flex;"}
::: {}
```{r Products to include 1,echo =F}
  selectInput(inputId="product_choice1", 
              label="Select products",
              choices = c("All","Livestock","Crops","None"),
              selected = "Crops",
              multiple = F, 
              width="140px")
```
:::
:::{}
```{r Products to include 2,echo =F}
product_choices<-reactive({
  if(input$product_choice1=="All"){X<-exposure_layers()[,sort(unique(product))]}
  if(input$product_choice1=="Livestock"){X<-exposure_layers()[category=="livestock",sort(unique(product))]}
  if(input$product_choice1=="Crops"){X<-exposure_layers()[category=="crop",sort(unique(product))]}
  if(input$product_choice1=="None"){X<-NULL}
  X
})

  renderUI({
    checkboxGroupInput(inputId="product_choice", 
                       label="",
                       choices = exposure_layers()[,sort(unique(product))],
                       selected = product_choices(),
                       inline=T)
  })
  
  exposure_layers_subset<-reactive({
    exposure_layers()[product %in% input$product_choice]
  })
```
:::
::::

Subset the climate hazards used in the analysis. We recommend no more than 3 or 4 hazards are included otherwise the combinations of multiple hazards become too numerous to visualize (see `Analysis: Combined hazards` tab).  
*Note number of dry days is not available in future scenarios due to the method of bias correction used in future scenarios, this does not directly correct for the rainfall frequency. NDD can be explored for the baseline in the Trends section.*

:::: {style="display: flex;"}
::: {}
```{r Hazard - Variables,echo=F}
renderUI({
  checkboxGroupInput(inputId="Analysis_Vars", 
              label="Hazards to include in analysis",
              choices = haz_names(),
              selected = haz_names()[c(9,11)],
              inline=T)
})

FileName2<-reactive({
  gsub("<","L",gsub(">","G",paste(unlist(Thresholds()[Renamed %in% input$Analysis_Vars,!"Renamed"]),collapse="")))
})

```
:::
:::{}
```{r Plot - Variables,echo=F}
renderUI({
  checkboxGroupInput(inputId="Plot_Vars", 
              label="Display hazards                        ",
              choices = input$Analysis_Vars,
              selected= input$Analysis_Vars, 
              width=length(input$Analysis_Vars)*80,
              inline=T)
})
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Geography -  Choose admin level, echo=F}
  selectInput(inputId="AdminLevel", 
              label="Admin level",
              choices = c("Admin1","Admin2"),
              selected = "Admin1",
              multiple = F, 
              width="140px")
```
:::
:::{}
```{r Geography - Choose admin1 A, echo=F}
  selectInput(inputId="Admin1_Selection", 
              label="Select admin1",
              choices = c("All","None",""),
              selected = "All",
              multiple = F, 
              width="140px")
```
:::
:::{}
```{r Geography - Choose admin1 B, echo=F}
renderUI({
  checkboxGroupInput(inputId="Admin1", 
                     label="",
                     choices = sort(unique(Geographies()$admin1$admin_name)),
                     selected = if(input$Admin1_Selection=="All"){
                         sort(unique(Geographies()$admin1$admin_name))
                         }else{
                           if(input$Admin1_Selection=="None"){
                             NULL
                           }
                         },
                     inline=T)
})
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Geography - Choose admin2 A, echo=F}
conditionalPanel(
  condition = "input.AdminLevel == 'Admin2'",
  selectInput(inputId="Selection", 
              label="Select admin2",
              choices = c("All","None",""),
              selected = "All",
              multiple = F, 
              width="140px")
)
```
:::
:::{}
```{r Geography - Choose admin2 B, echo=F}
conditionalPanel(
 condition = "input.AdminLevel == 'Admin2'",
  renderUI({
    checkboxGroupInput(inputId="Admin2", 
                       label="",
                       choices = sort(unique(Geographies()$admin2$admin_name[Geographies()$admin2$NAME_1 %in% input$Admin1])),
                       selected = if(input$Selection=="All"){
                         sort(unique(Geographies()$admin2$admin_name[Geographies()$admin2$NAME_1 %in% input$Admin1]))
                         }else{
                           if(input$Selection=="None"){
                             NULL
                           }
                         },
                       inline=T)
  })
)
```
:::
::::

```{r Set admin areas for extraction, echo=F}
SubGeog<-reactive({
    if(input$AdminLevel=="Admin2"){
      X<-Geographies()$admin2[Geographies()$admin2$admin_name %in% input$Admin2,]
    }else{
      X<-Geographies()$admin1[Geographies()$admin1$admin_name %in% input$Admin1,]
    }
  X
})

SubGeog_rast<-reactive({
  terra::rasterize(SubGeog(),PlotHazards(),field="admin_name")
  })

SPAM_GLW_SubGeog<-reactive({
  terra::mask(terra::crop(SPAM_GLW(),SubGeog()),SubGeog())
  })

exposure_by_adminX<-reactive({
  X<-data.table::copy(exposure_by_admin())
    if(input$AdminLevel=="Admin2"){
      X[,admin:=admin2][,admin1:=NULL][,admin2:=NULL]
      X<-X[admin %in% input$Admin2]
    }else{
      X<-X[,list(value=sum(value,na.rm=T)),by=list(layer_name,admin1,variable,unit,product)]
      setnames(X,"admin1","admin")
      X<-X[admin %in% input$Admin1]
    }
  
  # Add admin area
  admin_area<-data.table(admin=SubGeog()$admin_name,admin_area_ha=terra::expanse(SubGeog(),unit="ha"))
  X<-merge(X,admin_area,all.x=T)
  X<-relocate(X,admin_area_ha,.after=admin)
  
  # Add total
  X[,value_total:=value[product=="total"],by=list(admin,variable)][,value_perc:=round(100*value/value_total,3)]
  X
})
```

```{r Plot - prepare data for plotting hazards,echo=F}

PlotHazards<-reactive({
  terra::mask(terra::crop(Hazards()[["historic-historic"]],SubGeog()),SubGeog())
})

PlotHazards_future<-reactive({
  terra::mask(terra::crop(Hazards()[[input$Future]],SubGeog()),SubGeog())
})

PlotHazards_diff<-reactive({
 PlotHazards_future()- PlotHazards()
})
```

```{r Plot - prepare data for plotting hazards 2,echo=F}
addGeog1<-function(){terra::plot(terra::aggregate(SubGeog(),by="NAME_1"),add=T,border="black",lwd=input$borderwidth)}
addGeog2<-function(){terra::plot(SubGeog(),add=T,border="black",lwd=input$borderwidth)}
```

```{r Analysis -  Combine hazards,echo=F}
# Combine hazards into a single layer:
HazComb<-reactive({
  HazCombWrapper(Hazards=Hazards(),
                 SaveDir=SaveDir(),
                 Scenarios=Scenarios,
                 FileName=FileName2(),
                 SelectedHaz = input$Analysis_Vars)
  })

HazPalCombMean<-reactive({PalFun(PalName=input$Palette,
                      N=nrow(HazComb()[["MeanHaz"]][[input$Future]][["Classes"]]),
                      Names=HazComb()[["MeanHaz"]][[input$Future]][["Classes"]][["Hazard"]])
})

HazPalCombProp<-reactive({PalFun(PalName=input$Palette,
                      N=nrow(HazComb()[["PropHaz"]][[input$Future]][["Classes"]]),
                      Names=HazComb()[["PropHaz"]][[input$Future]][["Classes"]][["Hazard"]])
})
```

```{r Analysis - Summarize hazards by region and crop,echo=F}
# Summarize hazards by region and MapSPAM data
HazXRegion<-reactive({
  HazXRegionWrapper(SaveDir=SaveDir(),
                    FileName=FileName2(),
                    Exposure=SPAM_GLW(),
                    Cropland=Cropland(),
                    TotalPop=TotalPop(),
                    Geographies=Geographies(),
                    HazComb=HazComb())
})
```

#### Exposure Summary{.tabset .tabset-fade .tabset-pills}

:::: {style="display: flex;"}
:::{}
```{r Plot - Choose Exposure variable,echo=F}
renderUI({
  selectInput(inputId="exposure_variable", 
              label="Choose spam variable to display",
              choices = sort(unique(exposure_layers_subset()$variable)),
              selected=sort(unique(exposure_layers_subset()$variable))[1], 
              multiple = F, 
              width="280px")
})

exposure_unit<-reactive({exposure_layers_subset()[variable==input$exposure_variable,unique(unit)]})

Vals<-reactive({
  exposure_by_adminX()[product %in% input$product_choice,sort(unique(product))]
})

```
:::
:::{}
```{r Plot - Products to include 1,echo =F}
  selectInput(inputId="product_choice1a", 
              label="Select products",
              choices = c("All","Livestock","Crops","None"),
              selected = "All",
              multiple = F, 
              width="140px")
```
:::
:::{}
```{r Plot - Products to include 2,echo =F}
product_choices_a<-reactive({
  if(input$product_choice1a=="All"){X<-Vals()}
  if(input$product_choice1a=="Livestock"){X<-Vals()[Vals() %in% exposure_layers()[category=="livestock",sort(unique(product))]]}
  if(input$product_choice1a=="Crops"){
    X<-Vals()[Vals() %in% exposure_layers()[category=="crop",sort(unique(product))]]
    X<-X[!X %in% c("total","roots","temperate fruit","fruit","vegetables","banana and plantain","pulses","cereals",
                   "coffee","oil crops")]
    X
    }
  if(input$product_choice1a=="None"){X<-NULL}
  X
})
```
:::
:::{}
```{r Plot - Choose Exposure Crops,echo=F}
renderUI({
  checkboxGroupInput(inputId="exposure_crops", 
              label="Crops to include in plot",
              choices = Vals(),
              selected = product_choices_a(),
              inline=T)
})



# Sum values in the exposure_table
Exposure_table_sum<-reactive({
  exposure_by_adminX()[,list(value=sum(value,na.rm=T)),by=list(variable,unit,product)
                       ][,value_total:=value[product=="total"],by=list(variable)
                            ][,value_perc:=round(100*value/value_total,3)]
})

#Subset by selected variables and products for plotting
Exposure_barplot_data<-reactive({
  exposure_by_adminX()[variable %in% input$exposure_variable & product %in% input$exposure_crops
                       ][,layer_name:=NULL]
})

Exposure_barplot_sum_data<-reactive({
  X<-Exposure_table_sum()[variable %in% input$exposure_variable & product %in% input$exposure_crops]
  X[,product:=forcats::fct_reorder(product, value)]
  X
})

# Subset exposure rasters by selected variables and products
Exposure_plot<-reactive({
  SPAM_GLW_SubGeog()[[names(SPAM_GLW_SubGeog()) %in% paste0(input$exposure_crops,"-",input$exposure_variable,"-",exposure_unit())]]
})
```
:::
::::

##### Maps
```{r Plot - Exposure Map,echo=F}
renderPlot({
terra::plot(Exposure_plot(),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            pax=list(cex.axis = input$TextSize))

},height=Plot.Height, width=Plot.Width)

```

##### Barplot
**Values summed across all selected admin areas**
```{r Plot - Exposure BarPlot Sum,echo=F}
Exposure_sum_barplot<-reactive({
  g<-ggplot(data=Exposure_barplot_sum_data(), aes(x = product, y = value,fill=product)) + 
  geom_bar(stat = "identity",position = position_dodge(width = 0.9))+
  ggplot_theme()+
  labs(y=input$exposure_variable,x="product")+
  coord_flip()+
  theme(legend.position = "none")
  g
})

renderPlot({Exposure_sum_barplot()},height=Plot.Height, width=Plot.Width)

```

**Values per selected admin areas**  
*This plot is for looking at a few admin areas x crops at a time**
```{r Plot - Exposure BarPlot,echo=F}
Exposure_barplot<-reactive({
  g<-ggplot(data=Exposure_barplot_data(), aes(x = admin, y = value,fill=product)) + 
  geom_bar(stat = "identity",position = position_dodge(width = 0.9))+
  ggplot_theme()+
  labs(y=input$exposure_variable)+
  coord_flip()
  g
})

renderPlot({Exposure_barplot()},height=Plot.Height, width=Plot.Width)
```
##### Table
The table below shows total crop and livestock exposure variables per product per selected administrative areas.
```{r Plot - ExposureTable,echo=F}
  renderDT({
    datatable(dplyr::mutate_if(dplyr::mutate_if(exposure_by_adminX()[product %in% input$exposure_crops],is.numeric,~round(.,3)),is.character,~as.factor(.)),
              caption="",
              extensions = 'Buttons',
              filter = "top",
              options = list(dom = 'Blfrtip',
                             buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                             lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
    
  })
```

The table below sums crop and livestock exposure variables per product across all selected administrative areas.
```{r Plot - ExposureTable summed,echo=F}
  renderDT({
    datatable(dplyr::mutate_if(dplyr::mutate_if(Exposure_table_sum()[product %in% input$exposure_crops],is.numeric,~round(.,3)),is.character,~as.factor(.)),
              caption="",
              extensions = 'Buttons',
              filter = "top",
              options = list(dom = 'Blfrtip',
                             buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                             lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
    
  })
```

##### GLPS{.tabset .tabset-fade .tabset-pills}
Livestock intake and production loss data comes from [Thornton P, Nelson G, Mayberry D, Herrero M. Impacts of heat stress on global cattle production during the 21st century: a modelling study. The Lancet Planetary Health. 2022;6(3):e192-e201.](https://doi.org/10.1016/S2542-5196(22)00002-X).  

Losses are assigned to admin units according to the share of cattle within lps categories as compared to total cattle numbers for the lps category (if loss was 1000 for humid rangelands (LGH) and an admin unit contains 65% of cattle within humid rangelands then the admin unit share of loss for  LGH is 1000*0.65 = 650).  

Losses in meat and milk production (`meat_loss` and `milk_loss` cols) are the value of production lost compared with 2005 (USD 1000s, 2005 constant dollars). These values are adjusted to 2021 numbers using worldbank exchange rate (`PA.NUS.FCRF`) and CPI (`FP.CPI.TOTL.ZG`) indicators accessed with the `wbstats::wb_data` function.  
The `dmi` cols are the dry matter intake adjustment factor (which is estimated nationally for different lps).
```{r Analyse - GLPS,echo=F}
GLPS_table1<-reactive({
    if(input$AdminLevel=="Admin2"){
      Regions<-Geographies()$admin2
    }else{
      Regions<-Geographies()$admin1
    }


  GLPS_thornton<-terra::rast("./Data/GLPS/glps_gleam_61113_10km.tif")
  GLPS_thornton<-classify(GLPS_thornton,matrix(c(1:15,c(0,0,1,2,3,3,4,5,3,3,4,5,6,7,NA)),ncol = 2))
  
  GLPS_vals<-data.frame(Code=0:7,
                        Short=c("LGA", "LGH", "LGT", "MXA", "MXH", "MXT", "Urban", "Other"),
                        LPS=c("Rangelands Arid","Rangelands Humid","Rangelands Temperate","Mixed Arid","Mixed Humid","Mixed Temperate","Urban","Other"))

  levels(GLPS_thornton)<-GLPS_vals[,c("Code","LPS")]
  
  #GLPS_thornton<-terra::mask(terra::crop(GLPS_thornton,Regions),Regions)
    GLPS_thornton<-terra::mask(terra::crop(terra::resample(GLPS_thornton,Exposure(),method="near"),Regions),Regions)


  Regions$Code<-1:length(Regions)*100
  REG<-terra::rasterize(Regions,GLPS_thornton,field="Code")
  HAZ<-GLPS_thornton+REG
  names(HAZ)<-"GLPS"
  
  # Get area of glps per admin
  GLPS_area<-cellSize(GLPS_thornton,unit="ha")
  
  X<-data.table(zonal(GLPS_area,HAZ,fun=sum,na.rm=T))
  X[,admin:=floor(GLPS/100)*100]
  X[,GLPS:=GLPS-admin]
  X[,admin:=terra::values(Regions)[match(X$admin,Regions$Code),"admin_name"]]
  X[,GLPS_short:=GLPS_vals[match(X$GLPS,GLPS_vals$Code),"Short"]]
  X[,GLPS:=GLPS_vals[match(X$GLPS,GLPS_vals$Code),"LPS"]]
  
  admin_sizes<-data.table(admin=Regions$admin_name,admin_unit_ha=round(expanse(Regions,unit="ha"),2))
  X<-merge(X,admin_sizes)
  X[,perc:=round(100*area/admin_unit_ha,2)][,area:=round(area,2)]
  
  GLPS_table<-X
  
  # get cattle production per admin per GLPS
  cattle<-Exposure()[["cattle-production-k"]]
  
  X<-data.table(zonal(cattle,HAZ,fun=sum,na.rm=T))
  X[,admin:=floor(GLPS/100)*100]
  X[,GLPS:=GLPS-admin]
  X[,admin:=terra::values(Regions)[match(X$admin,Regions$Code),"admin_name"]]
  X[,GLPS_short:=GLPS_vals[match(X$GLPS,GLPS_vals$Code),"Short"]]
  X[,GLPS:=GLPS_vals[match(X$GLPS,GLPS_vals$Code),"LPS"]]
  names(X)[2]<-"cattle_prod"
  
  # get cattle production per GLPS total
  gpls_cattle<-data.table(zonal(cattle,GLPS_thornton,fun=sum,na.rm=T))
  colnames(gpls_cattle)<-c("GLPS","cattle_prod_tot")
  X<-merge(X,gpls_cattle,all.x=T,by="GLPS")
  X[,cattle_glps_prop:=round(cattle_prod/cattle_prod_tot,3)]
  
  cattle_admin_lps<-X
  
  # Merge area and cattle production results
  GLPS_table<-merge(GLPS_table,cattle_admin_lps[,list(admin,GLPS_short,cattle_glps_prop)],all.x=T,by=c("admin","GLPS_short"))
  
  # read in thornton et al. 2022 data
  dmi_econ_loss<-fread("./Data/thornton_lancet/dmi_and_econ_loss.csv")
  dmi_econ_loss<-dmi_econ_loss[ISO == country_zips[Country==input$country_choice,iso3c[1]]
                               ][,ISO:=NULL
                                 ][,Region:=NULL
                                   ][,`WTD-AV`:=NULL]
  dmi_econ_loss<-melt(dmi_econ_loss,id.vars = c("Country","Variable","Scenario"),variable.name = "GLPS_short")
  dmi_econ_loss[,value:=gsub(",","",value)][,value:=as.numeric(value)]
  dmi_econ_loss<-dcast(dmi_econ_loss,Country+Scenario+GLPS_short~Variable)
  dmi_econ_loss[,GLPS_short:=gsub(c("URB","OTHER"),c("Urban","Other"),GLPS_short)]
  
  # merge dmi data with GPLS system data
  GLPS_table<-merge(GLPS_table,by="GLPS_short",dmi_econ_loss[Scenario=="historical",list(GLPS_short,dmi)],all.x=T)
  setnames(GLPS_table,"dmi","dmi_hist")
  GLPS_table<-merge(GLPS_table,by="GLPS_short",dmi_econ_loss[Scenario=="2045_SSP585",list(GLPS_short,dmi)],all.x=T)
  setnames(GLPS_table,"dmi","dmi_2045_SSP585")
  GLPS_table[,dmi_diff:=dmi_2045_SSP585-dmi_hist
             ][,dmi_diff_perc:=round(100*dmi_2045_SSP585/dmi_hist,2)][,dmi_diff_perc:=dmi_diff_perc-100]
  
  # merge econ loss data with GPLS system data
  GLPS_table<-merge(GLPS_table,by="GLPS_short",dmi_econ_loss[Scenario=="2045_SSP585",list(GLPS_short,meat_loss,milk_loss)],all.x=T)
  setnames(GLPS_table,c("meat_loss","milk_loss"),c("meat_loss_2045_SSP585","milk_loss_2045_SSP585"))
  GLPS_table[,meat_loss_2045_SSP585:=cattle_glps_prop*as.numeric(meat_loss_2045_SSP585)
             ][,milk_loss_2045_SSP585:=cattle_glps_prop*as.numeric(meat_loss_2045_SSP585)]
  
# Convert 2005 IUSD to nearest year (2021)
  # Download worldbank CPI and exchange rate data
cpi_file<-paste0(SaveDir(),"/CPI.csv")
if(!file.exists(cpi_file)){
  cpi_data <- data.table(wbstats::wb_data("FP.CPI.TOTL", country_zips[Country==input$country_choice,iso3c][1]))
  fwrite(cpi_data,file=cpi_file)
  }else{
    cpi_data<-fread(cpi_file)
    }

xrat_file<-paste0(SaveDir(),"/Xrat.csv")
if(!file.exists(xrat_file)){
  exchange_rates <- data.table(wbstats::wb_data("PA.NUS.FCRF",country_zips[Country==input$country_choice,iso3c][1]))
  fwrite(exchange_rates,file=xrat_file)
  }else{
    exchange_rates<-fread(xrat_file)
    }

GLPS_table[,meat_loss_2045_SSP585_adj:=adj_usd(value=meat_loss_2045_SSP585,
                                               xrat_past=exchange_rates[date==2005,PA.NUS.FCRF][1],
                                               xrat_fut=exchange_rates[date==2021,PA.NUS.FCRF][1],
                                               index_past=cpi_data[date==2005,FP.CPI.TOTL][1],
                                               index_fut=cpi_data[date==2021,FP.CPI.TOTL][1])]

GLPS_table[,milk_loss_2045_SSP585_adj:=adj_usd(value=milk_loss_2045_SSP585,
                                     xrat_past=exchange_rates[date==2005,PA.NUS.FCRF][1],
                                     xrat_fut=exchange_rates[date==2021,PA.NUS.FCRF][1],
                                     index_past=cpi_data[date==2005,FP.CPI.TOTL][1],
                                     index_fut=cpi_data[date==2021,FP.CPI.TOTL][1])]
  
  GLPS_table
})

# Subset GLPS table by admin units selected
GLPS_table<-reactive({GLPS_table1()[admin %in% SubGeog()$admin_name]})
```

###### Table
```{r Plot - GLPS Table,echo=F}
renderDT({
  datatable(dplyr::mutate_if(dplyr::mutate_if(GLPS_table(),is.numeric,~round(.,3)),is.character,~as.factor(.)),
            caption="",
            extensions = 'Buttons',
            filter = "top",
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  
})
  
```

###### Barplot
```{r Plot - GLPS Barplot,echo=F}
GLPS_barplot<-reactive({
  g<-ggplot(data=GLPS_table(), aes(x = admin, y = area,fill=GLPS)) + 
  geom_bar(stat = "identity",position = position_dodge(width = 0.9))+
  ggplot_theme()+
  coord_flip()
  g
})

renderPlot({GLPS_barplot()},height=Plot.Height, width=Plot.Width)
```

#### Trends{.tabset .tabset-fade .tabset-pills}
```{r Trends - prepare data,echo=F}

data_ex1<-reactive({
  trends_extract(Geographies=Geographies(),
                 scenarios_x_hazards=scenarios_x_hazards,
                 DataDir=country_dir(),
                 SaveDir=SaveDir(),
                 haz_class=haz_class)
})


data_ex<-reactive({
  data_ex1()[,haz_name:=haz_names()[match(data_ex1()$hazard,hazards)]]
})
```

:::: {style="display: flex;"}
:::{}
```{r Trends - choose hazard,echo=F}
renderUI({
  selectInput(inputId="trend_haz_choice", 
              label="Choose hazard variable",
              choices =  c(haz_names(),"TAVG"),
              selected =  input$Analysis_Vars[1],
              multiple = F, 
              width="250px")
})
```
:::
:::{}
```{r Trends - Select future scenario,echo=F}
selectInput(inputId="trend_scenario", 
            label="Choose scenario",
            choices =  Scenarios$combined,
            selected =  "historic",
            multiple = F, 
            width="250px")
```
:::
:::{}
```{r Trends - Select Geogs 1,echo=F}
# Choose either to display trend for entire selected area or up to 4 subadmin units
    selectInput(inputId="trends_geog_choice", 
              label="Aggregate geographies or display a selection",
              choices = c("Aggregate", "Choose Selection"),
              selected="Choose Selection", 
              multiple = F,
              width="350px")

```
:::
::::

```{r Trends - Select Geogs 2,echo=F}
renderUI({
  #conditionalPanel(
   # condition = "input.trends_geog_choice == 'Choose Selection'",
    checkboxGroupInput(inputId="trends_admin_choice", 
                       label="Select regions",
                       choices = sort(unique(SubGeog()$admin_name)),
                       selected = sort(unique(SubGeog()$admin_name))[1:3],
                       inline=T)
 # )
})
```

```{r Trends -  Create Trend Line Plot, echo=F}

g_hist<-reactive({
  trend_plot_line(data=data_ex(),
             haz_class=haz_class,
             haz_choice=input$trend_haz_choice,
             admin_choice=input$trends_admin_choice,
             scenario_choice="historic",
             adminlevel_choice=tolower(input$AdminLevel),
             palette_choice=input$Palette)
})

if(F){
  g_future<-reactive({
    trend_plot_line(data=data_ex(),
               haz_class=haz_class,
               haz_choice=input$trend_haz_choice,
               admin_choice=input$trends_admin_choice,
               scenario_choice=input$trend_scenario,
               adminlevel_choice=tolower(input$AdminLevel),
               palette_choice=input$Palette)
  })
}

```

**Historical trend in selected variables**  
*Note this plot will only show the historical trend*
```{r Trends - Plot Lines - Historical,echo=F,eval=T}
renderPlot({plot(g_hist())},height=Plot.Height, width=Plot.Width)
```

```{r Trends - Plot Lines - Future,echo=F,eval=T}
if(F){renderPlot({plot(g_future())},height=Plot.Height, width=Plot.Width)}
```

**Scenario vs selected variables**  
```{r Trends -  Scenario Bar Plot, echo=F}
trends_bars<-reactive({
  trend_scenario_bars(data=data_ex(),
                      haz_choice=input$trend_haz_choice,
                      admin_choice=input$trends_admin_choice,
                      adminlevel_choice=tolower(input$AdminLevel))
})
```

```{r Trends - Plot Bars,echo=F,eval=T}
renderPlot({plot(trends_bars())},height=Plot.Height, width=Plot.Width)
```

```{r Trends - Table, echo=F}
renderDT({
  datatable(data_ex()[haz_name %in% input$trend_haz_choice & 
                        admin_name %in% input$trends_admin_choice & 
                        adminlevel==tolower(input$AdminLevel),list(admin_name,scenario,time,year,haz_name,mean,sd,class)],
            caption="Trends table",
            extensions = 'Buttons',
            filter = "top",
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  
})
```

```{r Trends - Table - Class Proportions, echo=F}
dt2_class<-reactive({
    data_ex()[haz_name %in% input$trend_haz_choice & 
              admin_name %in% input$trends_admin_choice & 
              adminlevel==tolower(input$AdminLevel)
  ][,list(class_prop=.N),by=list(admin_name,scenario,time,hazard,haz_name,adminlevel,scenario2,class)
    ][,class_prop:=class_prop/data_ex()[,length(unique(year2))]]
})

renderDT({
  datatable(dt2_class()[,list(admin_name,scenario,time,haz_name,class,class_prop)],
            caption="Trends table",
            extensions = 'Buttons',
            filter = "top",
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  
})

```
#### Severity and recurrance {.tabset .tabset-fade .tabset-pills}
##### Scenario means
```{r Plot - Means prepare data,echo=F}
SR_plot1_mean<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_mean")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_mean")]]
  names(historic)<-paste0("historic-",names(historic))
  names(future)<-paste0(input$Future,"-",names(future))
  x<-c(historic,future)
  x
})

SR_plot1_mean_diff<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_mean")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_mean")]]
  x<-future-historic
  names(x)<-paste0("difference-",names(x))
  x
})

SR_plot1_class<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_meanclass")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_meanclass")]]
  rast_names<-c(paste0("historic-",names(historic)),paste0(input$Future,"-",names(future)))
  x<-c(historic,future)
  for(i in 1:nlyr(x)){
  set.cats(x,layer=i,value=data.frame(id=c(0,1),presence=c("absent","present")))
  }
  names(x)<-rast_names
  x
})

SR_plot1_class_diff<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_meanclass")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_meanclass")]]*10
  rast_names<-names(historic)
  x<-future+historic
  for(i in 1:nlyr(x)){
    set.cats(x,layer=i,value=data.frame(id=c(0,1,10,11),diff=c("neither","past","future","past+future")))
  }
  names(x)<-rast_names
  x<-harmonize_rast_cat_cols(x,Palette = input$Palette)
  x
})

```

Mean values of climate variables
```{r Plot - Means,echo=F}
renderPlot({
terra::plot(SR_plot1_mean(),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            pax=list(cex.axis = input$TextSize),
            cex.main=input$TextSize*1.2,
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

Difference between historic and future scenarios for mean value of climate variables
```{r Plot - Means diff,echo=F}
renderPlot({
terra::plot(SR_plot1_mean_diff(),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            pax=list(cex.axis = input$TextSize),
            cex.main = input$TextSize*1.2,
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

Scenario means classified according to hazard thresholds
```{r Plot - Meanclass,echo=F}
renderPlot({
terra::plot(SR_plot1_class(),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize)
)
},height=Plot.Height, width=Plot.Width)
```

Agreement between historic and future scenarios for classified hazards
```{r Plot - Meanclass diff,echo=F}
renderPlot({
terra::plot(SR_plot1_class_diff(),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            main="Agreement",
            pax=list(cex.axis = input$TextSize)
)
},height=Plot.Height, width=Plot.Width)
```

##### Recurrence
```{r Plot - prepare Prop,echo=F}
SR_plot1_prop<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_prop")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_prop")]]
  names(historic)<-paste0("historic-",names(historic))
  names(future)<-paste0(input$Future,"-",names(future))
  x<-c(historic,future)
  x
})

SR_plot1_prop_diff<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_prop")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_prop")]]
  x<-future-historic
  names(x)<-paste0("difference-",names(x))
  x
})

SR_plot1_prop_class<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_propclass")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_propclass")]]
  rast_names<-c(paste0("historic-",names(historic)),paste0(input$Future,"-",names(future)))
  x<-c(historic,future)
  for(i in 1:nlyr(x)){
  set.cats(x,layer=i,value=data.frame(id=c(0,1),presence=c("absent","present")))
  }
  names(x)<-rast_names
  x
})

SR_plot1_prop_class_diff<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_propclass")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_propclass")]]*10
  rast_names<-names(historic)
  x<-future+historic
  for(i in 1:nlyr(x)){
    set.cats(x,layer=i,value=data.frame(id=c(0,1,10,11),diff=c("neither","past","future","past+future")))
  }
  names(x)<-rast_names
  x
})

```

Recurrence risk for climate hazards (the proportion of seasons where a hazard is present with all the years of a scenario)
```{r Plot - Prop,echo=F}
renderPlot({
terra::plot(SR_plot1_prop(),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize),
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

Difference between historic and future scenarios for recurrence risk of climate hazards
```{r Plot - Prop diff,echo=F}
renderPlot({
terra::plot(SR_plot1_prop_diff(),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize),
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

For each hazard if the recurrence risk is greater than the recurrence threshold, `r reactive({input$PropThreshold})`, then a hazard is considered to be present
```{r Plot - Propclass,echo=F}
renderPlot({
terra::plot(SR_plot1_prop_class(),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize)
)
},height=Plot.Height, width=Plot.Width)
```

Agreement between historic and future scenarios for classified hazards
```{r Plot - Propclass diff,echo=F}
renderPlot({
terra::plot(SR_plot1_prop_class_diff(),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            pax=list(cex.axis = input$TextSize),
            cex.main = input$TextSize*1.2
)
},height=Plot.Height, width=Plot.Width)
```

Recurrence risk for any one hazard being present
```{r Plot -  Prop Class Any Analysis,echo=F}
AnyFun<-function(X){
1-prod(1-X)
}

PlotHazards_any<-reactive({
  x<-terra::app(PlotHazards()[[paste0(input$Plot_Vars,"_prop")]],AnyFun)
  names(x)<-"historic"
  x
})

PlotHazards_future_any<-reactive({
  x<-terra::app(PlotHazards_future()[[paste0(input$Plot_Vars,"_prop")]],AnyFun)
  names(x)<-input$Future
  x
  })

PlotHazards_diff_any<-reactive({
 x<-PlotHazards_future_any()- PlotHazards_any()
 names(x)<-"future minus historic"
 x
})


SR_any_plot<-reactive({
  x<-c(PlotHazards_any(),PlotHazards_future_any(),PlotHazards_diff_any)
})

```

```{r Plot - Prop Class Any, echo=F}
renderPlot({
terra::plot(SR_any_plot(),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)

```

##### Severity

```{r Plot - Prepare exceedance mean,echo=F}
SR_plot1_exceed_mean<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_exceedmean")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_exceedmean")]]
  names(historic)<-paste0("historic-",names(historic))
  names(future)<-paste0(input$Future,"-",names(future))
  x<-c(historic,future)
  x
})

SR_plot1_exceed_mean_diff<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_exceedmean")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_exceedmean")]]
  x<-future-historic
  names(x)<-paste0("difference-",names(x))
  x
})


SR_plot1_exceed_max<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_exceedmax")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_exceedmax")]]
  names(historic)<-paste0("historic-",names(historic))
  names(future)<-paste0(input$Future,"-",names(future))
  x<-c(historic,future)
  x
})

SR_plot1_exceed_max_diff<-reactive({
  historic<-PlotHazards()[[paste0(input$Plot_Vars,"_exceedmax")]]
  future<-PlotHazards_future()[[paste0(input$Plot_Vars,"_exceedmax")]]
  x<-future-historic
  names(x)<-paste0("difference-",names(x))
  x
})

```

Hazard severity is the mean exceedance of a hazard threshold value (exceedance = abs(Value-Threshold)). It is calculated from only those seasons where a hazard is present (i.e., the hazard threshold is exceeded).
```{r Plot - Exceed mean,echo=F}
renderPlot({
terra::plot(SR_plot1_exceed_mean(),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

Difference between historic and future scenarios for mean exceedance of climate hazards.
```{r Plot - Exceed mean diff,echo=F}
renderPlot({
terra::plot(SR_plot1_exceed_mean_diff(),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

Hazard severity as the maximum exceedance of a hazard threshold value (exceedance = abs(Value-Threshold)) across all the years within a scenario.
```{r Plot - Exceed max,echo=F}
renderPlot({
terra::plot(SR_plot1_exceed_max(),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

Difference between historic and future scenarios for max exceedance of climate hazards.
```{r Plot - Exceed max diff,echo=F}
renderPlot({
terra::plot(SR_plot1_exceed_max_diff(),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            col=PalFun(PalName=input$Palette,
                      N=50,
                      Names=1:50)
)
},height=Plot.Height, width=Plot.Width)
```

##### Severity & recurrence {.tabset .tabset-fade .tabset-pills}
###### Table
```{r Table - Severity x Risk calculation, echo=F}
SxRtab_hist<-reactive({
  x<-SxRtabFun(Hazards=PlotHazards(),
            Plot_Vars=input$Plot_Vars,
            ExtractBy=SubGeog_rast())
  x[,Scenario:="historic"]
  x
})

SxRtab_future<-reactive({
  x<-SxRtabFun(Hazards=PlotHazards_future(),
            Plot_Vars=input$Plot_Vars,
            ExtractBy=SubGeog_rast())
  x[,Scenario:=input$Future]
  x
})

SxRtab_diff<-reactive({
  x<-SxRtabFun(Hazards=PlotHazards_future()-PlotHazards(),
            Plot_Vars=input$Plot_Vars,
            ExtractBy=SubGeog_rast())
  x[,Scenario:="Difference"]
  x
})


SxRtab<-reactive({
  x<-rbind(SxRtab_hist(),SxRtab_future(),SxRtab_diff())[,c(11,1:10)]
  setnames(x,c("prop","prop-sd"),c("recurrance_prop","recurrance_prop-sd"))
  x
})
```

This table presents the intersection of hazard severity and recurrence for the selected geographic area. The `mean` column is the average value of the climate variable. Severity is represented by the mean  and max exceedance of hazard threshold (`exceedmean` and `exceedmax` columns). Recurrence is represented by the proportion of years containing a hazard (`prop` column). Variables are averaged across all the values within an area.
```{r Table - Severity x Risk DT, echo=F}
renderDT({
  datatable(dplyr::mutate_if(dplyr::mutate_if(SxRtab(),is.numeric,~round(.,3)),is.character,~as.factor(.)),
            caption="Hazard recurrance x severity (means by geography)",
            extensions = 'Buttons',
            filter = "top",
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  
})

```

###### BarPlot
You can only display one admin unit at a time due to the number of variables in this plot.

:::: {style="display: flex;"}
::: {}
```{r BarPlot - Severity x Risk - Choose Admin, echo=F}
renderUI({
  selectInput(inputId="sr_admin", 
              label="Select admin",
              choices = SubGeog()$admin_name,
              selected =  SubGeog()$admin_name[1],
              multiple = F, 
              width="140px")
})
```
:::
:::{}
```{r BarPlot - Severity x Risk - Show errors, echo=F}
  selectInput(inputId="sr_errors", 
              label="show error bars?",
              choices = c("Yes","No"),
              selected = "No",
              multiple = F, 
              width="140px")
```
:::
::::

```{r BarPlot - Severity x Risk - Prepare data, echo=F}
SxRtab_plotdat<-reactive({
  X<-melt(SxRtab()[admin == input$sr_admin],id.vars = c("Scenario","admin","Hazard"))
  X[grepl("-",variable),error:=unlist(tstrsplit(variable,"-",keep=2))
              ][,variable:=unlist(tstrsplit(variable,"-",keep=1))
                ][is.na(error),error:="value"]
  X<-dcast(X,Scenario+admin+Hazard+variable~error)
  haz_drop<-X[,list(rmhaz=all(value==0)),by=Hazard][rmhaz==T,Hazard]
  X<-X[!Hazard %in% haz_drop]
  X
})

SxRtab_plot<-reactive({
g<-ggplot(data=SxRtab_plotdat(), aes(x = Scenario, y = value,fill=Scenario)) + 
  facet_wrap(Hazard~variable,scales = "free",ncol=4)+
  geom_bar(stat = "identity",position = position_dodge(width = 0.9))+
  ggplot_theme()+
  scale_x_discrete(guide = guide_axis(n.dodge = 3))
if(input$sr_errors=="Yes"){
  g<-g+geom_errorbar(aes(x=Scenario, ymin=value-sd, ymax=value+sd), width=0.4, colour="black",alpha=0.9, size=0.5)
  }
g
})
```

```{r BarPlot - Severity x Risk - Plot, echo=F}
renderPlot({SxRtab_plot()},height=Plot.Height, width=Plot.Width)
```

#### Combined hazards
*Note there is a potential issue when creating palette for combined hazards if different hazards are present in historic vs future*

```{r Plot - Prepare combinations mean,echo=F}
CombPlot_historic<-reactive({ 
   X<-terra::mask(
     terra::crop(x = HazComb()[["MeanHaz"]][["historic-historic"]][["RastReclass"]], SubGeog()),
     SubGeog())
      X<-droplevels(X)
      X
  })

CombPlot_future<-reactive({ 
  X<-terra::mask(
      terra::crop(x = HazComb()[["MeanHaz"]][[input$Future]][["RastReclass"]], SubGeog()),
      SubGeog())
  X<-droplevels(X)
  X
  })

CombPlot_agree_mean<-reactive({
  x<-CombPlot_historic()==CombPlot_future()
  levels(x)<-data.frame(c(T,F),c("no change","change"))
  x
})


CombPlot<-reactive({
  x<-c(CombPlot_historic(),CombPlot_future()) 
  names(x)<-c("historic",input$Future)
  harmonize_rast_cat_cols(x=x,Palette=input$Palette)
  x
})
```

```{r Plot - Plot combinations mean check levels match,echo=F}
renderPrint({
  if(all(levels(CombPlot_historic()[,2]==levels(CombPlot_future()[,2])))){
    "All hazard combinations match"
  }else{
     "Hazard combinations differ"
      CombPlot_historic()[,2]
      CombPlot_future()[,2]
  }
})
```

This plot shows the intersection of climate hazards classified using scenario means (average of all years).
```{r Plot - Plot combinations mean,echo=F}
renderPlot({
terra::plot(CombPlot(),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            col=PalFun(PalName=input$Palette,
                      N=nrow(levels(CombPlot())[[1]]),
                      Names=levels(CombPlot()))
)
},height=Plot.Height, width=Plot.Width)

```

```{r Plot - Prepare combinations prop,echo=F}
CombPlotProp_historic<-reactive({ 
  X<-terra::mask(
    terra::crop(x = HazComb()[["PropHaz"]][["historic-historic"]][["RastReclass"]], SubGeog()),
    SubGeog())
  X<-droplevels(X)
  X
  })

CombPlotProp_future<-reactive({ 
  X<-terra::mask(
    terra::crop(x = HazComb()[["PropHaz"]][[input$Future]][["RastReclass"]], SubGeog()),
    SubGeog())
    X<-droplevels(X)
    X
    })

renderPrint({
  if(all(levels(CombPlotProp_historic()[,2]==levels(CombPlotProp_future()[,2])))){
    "All hazard combinations match"
  }else{
     "Hazard combinations differ"
      CombPlotProp_historic()[,2]
      CombPlotProp_future()[,2]
  }
})

CombPlot_agree_prop<-reactive({
  x<-CombPlotProp_historic()==CombPlotProp_future()
  levels(x)<-data.frame(c(T,F),c("no change","change"))
  x
})

CombPlotProp<-reactive({
  x<-c(CombPlotProp_historic(),CombPlotProp_future()) 
  names(x)<-c("historic",input$Future)
  harmonize_rast_cat_cols(x=x,Palette=input$Palette)
  x
})

```

This plot shows the intersection of climate hazards classified using the recurrence risk threshold.
```{r Plot - Plot combinations prop,echo=F}
renderPlot({
terra::plot(CombPlotProp(),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
            col=PalFun(PalName=input$Palette,
                      N=nrow(levels(CombPlotProp())[[1]]),
                      Names=levels(CombPlotProp()))
)
},height=Plot.Height, width=Plot.Width)
```

This plot shows the agreement between historic and future hazards for the two different calculation methods (left is mean and right is recurrence risk)
```{r Plot - Plot agreement,echo=F}

CombPlot_agree<-reactive({
  x<-c(CombPlot_agree_mean(),CombPlot_agree_prop()) 
  names(x)<-c("agreement (scenario means)","agreement (recurrence risk)")
  x
})

renderPlot({
terra::plot(c(CombPlot_agree()),
            fun=if(input$AdminLevel=="Admin2"){addGeog2}else{addGeog1},
            cex.main = input$TextSize*1.2,
            pax=list(cex.axis = input$TextSize),
            plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols)
)
},height=Plot.Height, width=Plot.Width)
```

#### Risk x Exposure {.tabset .tabset-fade .tabset-pills}
This section takes the combined hazards and intersects them with spatial datasets that represent exposure, namely human rural population and the harvested area of different crops (source:MapSPAM). You can choose the shareholding method which determines the combined hazards layer used for intersection. *It is possible to choose other MapSPAM crop statistics such as total production or value of production, but this functionality is not yet implemented*.

```{r Table -  Method, echo=F}
selectInput(inputId="HazMeth1",
             label="Thresholding method", 
            choices = c("Scenario mean","Recurrence"),
            selected = "Scenario mean",
            multiple = F, 
            width="150px")

HazMeth<-reactive({
  if(input$HazMeth1=="Recurrence"){
    "PropHaz"
  }else{
    "MeanHaz"
  }
})
```

##### Cropland exposure
The table below shows the summarize exposure of rural population and cropland areas within administrative unit. Each row is a hazard x administrative unit. The columns within the table show the following:  
1) the total administrative unit area (ha, `Admin_Area`);  
2) area of cropland (ha, `Cropland_Area_sum`) and % of cropland (`Cropland_Perc`);  
3) human rural population (thousands, `TotalPop_sum`);  
4) % of rural population and cropland exposed to historical climate hazards  (`Past_Crop_Risk_Perc` and `Past_Pop_Risk_Perc` columns); and  
5) % of rural population and cropland exposed to future climate hazards  (`Fut_Crop_Risk_Perc` and `Fut_Pop_Risk_Perc` columns).

```{r Analysis - Subset data PopCrop,echo=F}
DT_Data_historic<-reactive({
  X<-PrepTable(Data=HazXRegion(),
                   Method=HazMeth(),
                   Scenario="historic-historic",
                   AdminLevel=input$AdminLevel,
                   A1=input$Admin1,
                   A2=input$Admin2,
                   Table="CropPop")[,Scenario:="historic"]
  
  setnames(X,c("Cropland_Risk_Perc","Pop_Risk_Perc"),c("Past_Crop_Risk_Perc","Past_Pop_Risk_Perc"))
  X[,Scenario:=NULL]
  X
})

DT_Data_future<-reactive({
  X<-PrepTable(Data=HazXRegion(),
             Method=HazMeth(),
             Scenario=input$Future,
             AdminLevel=input$AdminLevel,
             A1=input$Admin1,
             A2=input$Admin2,
             Table="CropPop")[,Scenario:=input$Future]
  setnames(X,c("Cropland_Risk_Perc","Pop_Risk_Perc"),c("Fut_Crop_Risk_Perc","Fut_Pop_Risk_Perc"))
  X[,Scenario:=NULL]
  X
})

DT_Data<-reactive({
  X<-merge(DT_Data_historic(),DT_Data_future(),all.x=T)
  X
})
```

```{r Analysis - Display DT PopCrop,echo=F}
renderDT({
  datatable(dplyr::mutate_if(DT_Data(),is.character,~as.factor(.))[,TotalPop_sum:=round(TotalPop_sum,3)
                                                                   ][,Admin_Area:=round(Admin_Area,3)
                                                                     ][,Cropland_Area_sum:=round(Cropland_Area_sum,3)],
            caption="Cropland hazards by geography",
            extensions = 'Buttons',
            filter = "top",
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  
})

```

##### Hazard x crop x geography

```{r Hazard x crop x geography - Perc, echo=F}
selectInput(inputId="hcg_perc", 
            label="Show percentages?",
            choices = c("Yes","No"),
            selected =  "No",
            multiple = F, 
            width="140px")
``` 
For each administrative unit the table below intersects commodity specific exposure variables with climate hazards.
```{r Hazard x crop x geography - Subset data,echo=F}

DT_Data2_historic<-reactive({
  X<-PrepTable(Data=HazXRegion(),
                   Method=HazMeth(),
                   Scenario="historic-historic",
                   AdminLevel=input$AdminLevel,
                   A1=input$Admin1,
                   A2=input$Admin2,
                   Table="Exposure")[,Value:=round(Value,1)
                                 ][,Scenario:="historic"]
  X
})

DT_Data2_future<-reactive({
  X<-PrepTable(Data=HazXRegion(),
                   Method=HazMeth(),
                   Scenario=input$Future,
                   AdminLevel=input$AdminLevel,
                   A1=input$Admin1,
                   A2=input$Admin2,
                   Table="Exposure")[,Value:=round(Value,1)
                                 ][,Scenario:=input$Future]
  X
})

DT_Data2<-reactive({
 
  X<-merge(DT_Data2_future(),DT_Data2_historic(),by=colnames(DT_Data2_historic())[1:3],all.x=T)
  X[,'Scenario.x':=NULL][,'Scenario.y':=NULL]
  setnames(X,c("Value.x","Value.y"),c("future","historic"))
  
  X[,difference:=future-historic
    ][,Variable:=unlist(tstrsplit(Crop,"-",keep=2))
      ][,Unit:=unlist(tstrsplit(Crop,"-",keep=3))
        ][,Crop:=unlist(tstrsplit(Crop,"-",keep=1))
          ][,Admin_total:=sum(historic,na.rm=T),by=list(Admin,Variable,Crop)]

  if(input$hcg_perc=="Yes"){
    X[,future:=round(100*future/Admin_total,2)
      ][,historic:=round(100*historic/Admin_total,2)
        ][,difference:=round(100*future/difference,2)]
  }
  
  X<-X[historic!=0
       ][,c(1:3,7:8,9,4:6)]
  
  setnames(X,"future",input$Future)
  
  X
  })

DT_Data3<-reactive({DT_Data2()[Crop %in% input$product_choice]})


```

```{r Hazard x crop x geography - Table,echo=F}
renderDT({
  datatable(dplyr::mutate_if(DT_Data3(),is.character,~as.factor(.)),
            caption="Crop VoP exposed to hazards",
            extensions = 'Buttons',
            filter = "top",
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  
})

```



### To Do List
1) Errors from multiple models not just ensembles  
2) Exposure summary tab for crops (done), population, production  
4) Hazard Index - normalize severity and recurrence to create a relative index? the relative component may be problematic as it could over-emphasize minor hazards  
9) Increase hazards classification options to include all classes, whilst retaining option to choose which class to move forward with. 
9a) Crop vs exposure to different hazard severity indices (10% product is moderate, 20% severe, etc.)
10) Box plots  
11) Plotting refinements (use a different plotting package):  
  11a) fix scaling issue with terra::plot  
  11b) Save plot options + edit labels options  
  11c) Scale font size of terra::plots (axis & legend)  
  11d) Pallete (gg), line size (gg), add points (gg)  
13) Refinement of handling of hazard cats can we include severity in categorical combinations  
14) Ordination of hazards  
16) Sanky diagrams for flow from one hazard to another  
17) Admin0  
18) Anomaly approach  
19) Different baselines
20) Download this map option
21) Reference data should come from a meta-data files?
22) Hazard summary section - display hazards x severity maps for country in hazard or results section
23) Show hazard thresholds at top of results section or in maps
24) Ability to split out irrigated crop production
25) Add option to choose OCHA or GADM boundaries


**Bugs & Urgent Description Needs**
1) historic vs future plots should use the same legend scale  
2) Recurrence - prop plots (at least for TAI) appear to show a categorical legend as well as a continuous legend (update - seems to be an issue with with 0/1 plots)  
3) Exposure summary - move plotting subsetting to plot only (so that the Table tab is not affected)  
4) FIXED Paletting issue for combinations - when haz combinations do not match between historic and future scenarios this causes issues. Can be replicated by selecting muliple hazards and reducing scale from country to smaller admin units.
5) Add unit meta-data -> HxCxG table
6) Explain what is annual vs seasonal
7) Crop selection is not working at higher level
8) Is changing recurrance threshold doing anything? it appears not
9) Cropland exposure tab needs units
10) Update descriptions of THI and HSH
11) Choose future scenario is not working in the trends section, also historic select is incorrect
